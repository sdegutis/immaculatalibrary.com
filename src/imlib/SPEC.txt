

Engine input data:

  { [key: string]: object }[]

  Used for routes, views, data, helpers, etc.


Engine rules (i.e. app.start):

  1. Process each item in data
  2. Link items via $type (avoiding cycles)
  3. Populate item.items[]
  4. Inherit figures
  5. Whitelist globals via shadows
  6. Build site.root, site.items
  7. Start routes, timers, boots


Special item fields (all optional):

  $name
    => assigned under type's $name in site.root
    => note: top-down, so must be reachable

  $type, $figure, $shadow
    => for each $type by id (deepest first)
      => inherit this[keys] from type.$figure
      => whitelists globals via type.$shadow

  $route, $get, $post, $delete, $put, $patch, $head, $options
    => if $route is non-blank string, route each verb-fn

  $tick & $ms
    => call $tick every $ms seconds

  $boot
    => run after each site build


Item API:

  this: always executing item

  item[key]   => item.computed[key]
  item.$id    => string
  item.$data  => raw object for item
  item.$items => items with this direct type
  item.$type  => item or null


Site API:

  site.items: { id: item }
  site.root: { '$$'+name: root item }
  site.create(data): new id
  site.update(id, data)
  site.delete(id)
  site.rebuild()

Globals:

  Note: these can all be shadowed
  Note: shadowing is a whitelist

  $site: current site
  [globals]: app.sandbox


Route API:

  Request:

    query(): URLSearchParams from query
    text(): string from body
    json(): object from body
    form(): URLSearchParams from body
    headers(): express.js headers object
    session: object

  return Promise<string | {
    status?: number
    headers?: object
    (redirect: string |
     text: string |
     json: object)
  }>


Computing:

  { eval: string } => returns vm2.eval(s)
  any other value  => that value

  eval context has access to JSX
    JSX.createElement
    JSX.fragment
