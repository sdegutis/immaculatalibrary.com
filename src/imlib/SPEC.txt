

Engine input data:

  { [key: string]: object }[]

  Used for routes, views, data, helpers, etc.


Engine rules (i.e. app.start):

  1. Link items via $type
  2. Apply type figures
  3. Cast global shadows
  4. Build site structures
  5. Compute item properties
  6. Start timers, routes, boots
  7. On site.rebuild() goto #1


Computing:

  { $eval: string } => returns vm2.eval(s)
  any other value  => that value

  What 'this' is in each context:
    Item:   defining item
    Shadow: defining item
    Figure: destination item

  All eval contexts have access to JSX, including:
    JSX.createElement
    JSX.fragment


Special item fields (all optional):

  $name
    => used for site.named()

  $type, $figure, $shadow
    => for each $type by id (deepest first)
      => inherit this[k] from type.$figure
      => inherit globals from type.$shadow

  $route, $get, $post, $delete,
  $put, $patch, $head, $options
    => if $route is non-blank string, route each verb-fn

  $tick & $ms
    => call $tick every $ms seconds

  $boot
    => run after each site build


Item API:

  item[key]   => item.computed[key]
  item.$id    => string
  item.$data  => raw object for item
  item.$items => items with this direct type
  item.$type  => item or null


Site API:

  site.items: { id: item }
  site.root: top-level item[]
  site.named(path: string[])
  site.create(data): new id
  site.update(id, data)
  site.delete(id)
  site.rebuild()
    tries to build new site
    pushes db changes if worked
    returns { site } or { error }


Route API:

  Input parameter:

    query(): URLSearchParams from query
    text(): string from body
    json(): object from body
    form(): URLSearchParams from body
    headers(): express.js headers object
    session: object

  return Promise<string | {
    status?: number
    headers?: object
    (redirect: string |
     text: string |
     json: object)
  }>


Globals:

  $site: current site
  [globals]: app.sandbox

  Note: these can all be shadowed
  Note: to hide, shadow as null or anything
